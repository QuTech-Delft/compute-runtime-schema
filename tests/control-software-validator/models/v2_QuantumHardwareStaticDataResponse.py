# generated by datamodel-codegen:
#   filename:  QuantumHardwareStaticDataResponse.schema.json

from __future__ import annotations

from typing import Any, Dict, List, Literal, Optional

from pydantic import BaseModel, Field, RootModel


class CompilerPass(BaseModel):
    path: str = Field(
        ...,
        description='Path to OpenSquirrel object that does the compiler pass',
        examples=['opensquirrel.passes.decomposer.mckay_decomposer.McKayDecomposer'],
        title='Path',
    )
    method: str = Field(
        ...,
        description='Method on OpenSquirrel object that does the compiler pass',
        examples=['decompose'],
        title='Method',
    )
    arguments: Optional[Dict[str, Any]] = Field(
        {}, description='Arguments for the compiler pass', title='Arguments'
    )


class TopologyItem(RootModel[List]):
    root: List = Field(..., max_length=2, min_length=2)


class Topology(RootModel[List[TopologyItem]]):
    root: List[TopologyItem] = Field(
        ...,
        description='A class representing the topology of a quantum chip.\n\nIt is a list of tuples, where each tuple represents a unidirectional connection between two qubits. The first\nelement of the tuple is the source qubit, and the second element is the target qubit.',
        title='Topology',
    )


class CompilerConfig(BaseModel):
    decomposition: Optional[List[CompilerPass]] = Field([], title='Decomposition')
    mapping: Optional[List[CompilerPass]] = Field([], title='Mapping')
    optimization: Optional[List[CompilerPass]] = Field([], title='Optimization')
    routing: Optional[List[CompilerPass]] = Field([], title='Routing')


class StaticDataSchema(BaseModel):
    protocol_version: Optional[int] = Field(
        2,
        description='Version of the Compute Runtime Schema to use',
        title='Protocol Version',
    )
    nqubits: int = Field(..., description='The number of qubits.', title='Nqubits')
    topology: Topology = Field(
        ..., description='List of the edges between the various qubits'
    )
    name: str = Field(..., description='Name of the system.', title='Name')
    pgs: List[str] = Field(
        ...,
        description='Supported primitive gates set of the system. Gate names as described in cQASM (in uppercase).',
        title='Pgs',
    )
    default_compiler_config: Optional[CompilerConfig] = Field(
        default_factory=lambda: CompilerConfig.model_validate(
            {'decomposition': [], 'mapping': [], 'optimization': [], 'routing': []}
        ),
        description='A suitable default compiler configuration for the hardware backend',
    )
    starttime: float = Field(
        ...,
        description='Timestamp of start-up of the system (return value of time.time())',
        title='Starttime',
    )
    supports_raw_data: Optional[bool] = Field(
        False,
        description='Whether the hardware backend supports shot memory. If True, the include_raw_data flag in the QuantumHardwareRunCircuitPayload should trigger the backend to store shot memory in the raw_data field of the results.',
        title='Supports Raw Data',
    )


class V2QuantumHardwareStaticDataResponse(BaseModel):
    version: str = Field(..., pattern='^\\d+\\.\\d+\\.\\d$', title='Version')
    status: Literal['success'] = Field(..., title='Status')
    payload: StaticDataSchema
