{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Interface","text":"<p>The job processor (2200) and control-software (2300) are python software components that run in different python processes either on the same or different PCs. The interface consists of the following functions:</p> <ul> <li>Locking: Function to avoid 2300 interrupting a 2200 algorithm.</li> <li>Execution: Function to execute algorithm.</li> <li>Meta communication: Function to retrieve system information from 2300</li> </ul> <p>Although this ICD was originally intended for a spin quantum runtime, an effort was made to make this a generic interface that can easily be extended to other quantum runtimes. To achive this the functions above will be performed in two different communication modi; request/reply and publish/subscribe. The interface for both modi consists of two layers: a message layer and an application layer.</p> <ul> <li>Request/Reply</li> <li>Publish/Subscribe</li> </ul>"},{"location":"messages.html","title":"Messages","text":"<p>The message templates that are used for communication between 2200 and 2300 are described below. The base message format is used for standalone messages, while the extended message format allows to link messages that are technically independent, but logically connected. These messages are python dictionaries that are converted from/to python strings via the JSON serializer of the python standard library (<code>json.loads</code> and <code>json.dumps</code> functions).</p>"},{"location":"messages.html#base-message","title":"Base message","text":"<p>The message described below has the most basic information needed for standalone messages. JSON schemas will be provided for these messages and should be inherited from for every relevant message.</p> <p>Info</p> <p>The schemas are automatically generated. This means that these requests and replies are already included in the schemas. The content is left here to illustrate the basis of the various schemas.</p>"},{"location":"messages.html#base-request","title":"Base request","text":"Key Type Value <code>command</code> <code>str</code> A string identifying the function to be executed. <code>payload</code> <code>dict</code> Arguments for the function to be executed. Presence of this key-value pair depends on the specific command. base_request.json<pre><code>{\n    \"command\": \"execute\",\n    \"payload\": {\n        // optional\n    },\n}\n</code></pre>"},{"location":"messages.html#base-reply","title":"Base reply","text":"Key Type Value <code>status</code> <code>str</code> \"success\" or \"failure\", depending on whether the command executed successfully. <code>payload</code> <code>dict</code> The return value(s) of the executed command (presence of this key-value pair then depends on the specific command). <code>payload.error_msg</code> <code>str</code> If <code>\"status\" == \"failure\"</code>: a string describing the failure in more detail."},{"location":"messages.html#base-reply-success","title":"Base reply success","text":"base_reply_success.json<pre><code>{\n    \"status\": \"success\",\n    \"payload\": {\n        // optional\n    },\n}\n</code></pre>"},{"location":"messages.html#base-reply-failure","title":"Base reply failure","text":"base_reply_failure.json<pre><code>{\n    \"status\": \"failure\",\n    \"payload\": {\n        \"error_msg\": \"Lorem ipsum\"\n    },\n}\n</code></pre>"},{"location":"messages.html#extended-messages","title":"Extended messages","text":"<p>An extended version of the messages exists. Next to the key-value pairs already present in these messages, it also contains parameters to link logically-connected messages. JSON schemas will be provided for these messages and should be inherited from for every relevant message.</p> <p>Info</p> <p>The schemas are automatically generated. This means that these requests and replies are already included in the schemas. The content is left here to illustrate the basis of the various schemas.</p>"},{"location":"messages.html#extended-request","title":"Extended request","text":"Key Type Value <code>session_id</code> <code>str</code> An arbitrary string, filled in in the request, which is copied into the reply object. Normally this would contain a unique identifier for the request, e.g., a UUID extended_request.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"command\": \"execute\",\n    \"payload\": {\n        // optional\n    },\n}\n</code></pre>"},{"location":"messages.html#extended-reply","title":"Extended reply","text":"Key Type Value <code>session_id</code> <code>str</code> The same <code>session_id</code> from the request to link the request and reply. extended_reply.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"status\": \"success\",\n    \"payload\": {\n        // optional\n    },\n}\n</code></pre>"},{"location":"publish/index.html","title":"Publish/Subscribe","text":"<p>For publish/subscribe, a broadcast model is followed. 2300 acts as a sender, while 2200 listens to the various messages.</p>"},{"location":"publish/index.html#message-layer","title":"Message layer","text":"Property Value Middleware ZMQ sockets version 4.x ZMQ message pattern Publish-subscribe. 2200 using SUB socket and 2300 PUB socket Publish binding argument <code>tcp://*:4204</code> i.e., uses underlying TCP socket connect to port 4204. Subscriber connect argument <code>tcp://&lt;host address&gt;:4204</code>. The <code>&lt;host address&gt;</code> contains the IP address of 2300. <p>The messages in this section inherit from generic messages described in the messages spec. Since messages will only be broadcasted, only the base request will be used. Any new messages should also inherit from this message.</p>"},{"location":"publish/index.html#application-layer","title":"Application layer","text":"<p>The application layer contains the specific application functions that are described in the root document. The functions are described via the contents of the published dictionaries.</p>"},{"location":"publish/meta.html","title":"Meta communication","text":"<p>System information from 2300 is divided over both request/reply and publish/subscribe. The messages below are published by 2300.</p>"},{"location":"publish/meta.html#publish-state","title":"Publish state","text":"<p>System 2300 publishes a state message to inform subscribers of its current state. This happens both via a heartbeat (\"am I still responsive\") and the state the system is in.</p> <p>Info</p> <p>The schemas for validation inherit can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/PublishState.schema.json</code></li> </ul>"},{"location":"publish/meta.html#publish-state-payload","title":"Publish state payload","text":"Key Type Value <code>state</code> <code>str</code> The current state of the system in all-capitals (i.e. <code>IDLE</code>, <code>EXECUTING</code>, <code>CALIBRATING</code>, <code>OFFLINE</code>) <code>timestamp</code> <code>float</code> Timestamp of the instantiation of the message (return value of <code>time.time()</code>) <p>The various states are defined as described below. The first state that applies from top to bottom, is used in the published message.</p> <ul> <li><code>OFFLINE</code>: 2300 is controlled manually or not reachable,</li> <li><code>CALIBRATING</code>: 2300 is calibrating,</li> <li><code>EXECUTING</code>: 2300 is initialized for execution and not yet terminated,</li> <li><code>IDLE</code>: 2300 is not executing experiments and being calibrated.</li> </ul>"},{"location":"publish/meta.html#publish-state-example","title":"Publish state example","text":"publish_state.json<pre><code>{\n    \"command\": \"publish_state\",\n    \"payload\": {\n        \"state\": \"IDLE\",\n        \"timestamp\": 1690061619.610174\n    },\n}\n</code></pre>"},{"location":"request/index.html","title":"Request/Reply","text":"<p>For request/reply, the interface will be a client-server interface. 2200 acts as the client and 2300 as the server. It follows the semantics of remote procedure calls (RPCs), i.e., the client \"calls\" a function that is \"remotely\" executed on the server and the result is passed back to the client.</p>"},{"location":"request/index.html#message-layer","title":"Message layer","text":"Property Value Middleware ZMQ sockets version 4.x ZMQ message pattern Request-reply. 2200 using REQ socket and 2300 REP socket Server binding argument <code>tcp://*:4203</code> i.e., uses underlying TCP socket connect to port 4203. Client connect argument <code>tcp://&lt;host address&gt;:4203</code>. The <code>&lt;host address&gt;</code> contains the IP address of 2300. <p>The messages in this section inherit from generic messages described in the messages spec. Any new messages should also inherit from these messages.</p>"},{"location":"request/index.html#application-layer","title":"Application layer","text":"<p>The application layer contains the specific application functions that are described in the root document. The functions are described via the contents of the request and reply dictionaries.</p>"},{"location":"request/execute.html","title":"Execution","text":"<p>Execute an algorithm on 2300. This is only allowed when 2300 is in non-interruption mode. So for a single execution three commands are required, \"initialize\", \"execute\", \"terminate\".</p>"},{"location":"request/execute.html#execute","title":"Execute","text":"<p>This message requests a backend to execute a user generated circuit. This can only be done when the system has been initialized (in reality \"locked\").</p> <p>Info</p> <p>The schemas for validation  can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareExecuteRequest.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareExecuteResponse.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareFailureResponse.schema.json</code></li> </ul>"},{"location":"request/execute.html#execute-request-payload","title":"Execute request payload","text":"Key Type Value <code>job_id</code> <code>int</code> Client defined identifier for the execution. <code>circuit</code> <code>str</code> Circuit description in cQASM language, see below for more information. <code>include_raw_data</code> <code>bool</code> Whether or not to return all bitstrings in the order in which they were measured. <code>number_of_shots</code> <code>int</code> Number of shots to be executed for the circuit. <p>The cQASM language is described in detail here. Different implementations of 2300 might impose different requirements. These will be described on a per case basis.</p>"},{"location":"request/execute.html#execute-request-example","title":"Execute request example","text":"execute_request.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"command\": \"execute\",\n    \"payload\": {\n        \"job_id\": 1,\n        \"circuit\": \"version 3.0\\n\\nqubits[2] q\",\n        \"include_raw_data\": true,\n        \"number_of_shots\": 4\n    },\n}\n</code></pre>"},{"location":"request/execute.html#execute-reply-payload","title":"Execute reply payload","text":"Key Type Value <code>job_id</code> <code>int</code> Client defined identifier for the execution. <code>results</code> <code>dict[str, int]</code> Mapping of measured bitstring (for a circuit with <code>n</code> measurements; <code>q[n]...q[0]</code>) to count of occurrences. Limited to <code>m</code> results. <code>raw_data</code> <code>list[str]</code> A list of bitstrings (little endian notation; <code>q[n]...q[0]</code>) ordered by the shot in which it was measured. If <code>include_raw_data</code> is set to <code>false</code> the list is left empty."},{"location":"request/execute.html#execute-reply-example","title":"Execute reply example","text":"execute_reply.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"status\": \"success\",\n    \"payload\": {\n        \"job_id\": 1,\n        \"results\": {\n            \"000\": 3,\n            \"001\": 1\n        },\n        \"raw_data\": [\n            \"000\",\n            \"001\",\n            \"000\",\n            \"000\"\n        ]\n    },\n}\n</code></pre>"},{"location":"request/locking.html","title":"Locking","text":"<p>This function consists of two RPCs. One to disable the algorithm interruption and one to enable it again.</p>"},{"location":"request/locking.html#initialize","title":"Initialize","text":"<p>This message signals to the 2300 that execution is about to begin. The initialize should be picked up as a request for locking 2300. However, this interpretation is left to this component.</p> <p>Info</p> <p>The schemas for validation can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareInitializeRequest.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareSimpleSuccessResponse.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareFailureResponse.schema.json</code></li> </ul>"},{"location":"request/locking.html#initialize-request-payload","title":"Initialize request payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/locking.html#initialize-request-example","title":"Initialize request example","text":"initialize_request.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"command\": \"initialize\",\n}\n</code></pre>"},{"location":"request/locking.html#initialize-reply-payload","title":"Initialize reply payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/locking.html#initialize-reply-example","title":"Initialize reply example","text":"initialize_reply.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"status\": \"success\",\n}\n</code></pre>"},{"location":"request/locking.html#terminate","title":"Terminate","text":"<p>The opposing message for the initialize request. When 2300 receives this request, execution from user generated circuits has stopped and the system can resume normal operations.</p> <p>Info</p> <p>The schemas for validation can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareTerminateRequest.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareSimpleSuccessResponse.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareFailureResponse.schema.json</code></li> </ul>"},{"location":"request/locking.html#terminate-request-payload","title":"Terminate request payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/locking.html#terminate-request-example","title":"Terminate request example","text":"terminate_request.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"command\": \"terminate\",\n}\n</code></pre>"},{"location":"request/locking.html#terminate-reply-payload","title":"Terminate reply payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/locking.html#terminate-reply-example","title":"Terminate reply example","text":"terminate_reply.json<pre><code>{\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"status\": \"success\",\n}\n</code></pre>"},{"location":"request/meta.html","title":"Meta communication","text":"<p>System information from 2300 is divided over both request/reply and publish/subscribe. The messages below are published by 2300.</p>"},{"location":"request/meta.html#get-static","title":"Get static","text":"<p>Get system information from 2300. This information is retrieved only once, normally at startup time for 2200.</p> <p>Info</p> <p>The schemas for validation can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareStaticDataRequest.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareStaticDataResponse.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareFailureResponse.schema.json</code></li> </ul> <p>or the alternative failure response for version 2 and older:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareDataFailureResponse.schema.json</code></li> </ul>"},{"location":"request/meta.html#get-static-request-payload","title":"Get static request payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/meta.html#get-static-request-example","title":"Get static request example","text":"get_static_request.json<pre><code>{\n    \"command\": \"get_static\",\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n}\n</code></pre>"},{"location":"request/meta.html#get-static-reply-payload","title":"Get static reply payload","text":"Key Type Value <code>nqubits</code> <code>int</code> The number of qubits <code>protocol_version</code> <code>int</code> The version of this protocol that is being used <code>topology</code> <code>array[tuple]</code> List of the edges between the various qubits <code>name</code> <code>str</code> Name of the system <code>pgs</code> <code>array[str]</code> Supported primitive gates set of the system. Gate names as described <code>instructions</code> (bottom of file) in QuIS <code>starttime</code> <code>float</code> Timestamp of start-up of the system (return value of <code>time.time()</code>) <code>default_compiler_config</code> <code>object[str,array[object[str, Any]]]</code> Compiler configurations for different stages. <code>supports_raw_data</code> <code>bool</code> Default <code>False</code>. Whether the hardware backend supports <code>raw_data</code>. If <code>True</code>, the <code>include_raw_data</code> flag in the execute message should trigger the backend to store the measurements per shot in the raw_data field of the results."},{"location":"request/meta.html#get-static-reply-example","title":"Get static reply example","text":"get_static_reply.json<pre><code>{\n    \"status\": \"success\",\n    \"payload\": {\n        \"nqubits\": 5,\n        \"protocol_version\": 3,\n        \"topology\": [\n            [0, 2],\n            [1, 2],\n            [3, 2],\n            [4, 2]\n        ],\n        \"name\": \"Starmon-5\",\n        \"pgs\": [\n            \"X\",\n            \"Y\"\n        ],\n        \"starttime\": 1690061619.610174,\n        \"supports_raw_data\": true,\n        \"default_compiler_config\": {\n            \"decomposition\": [\n                {\n                    \"path\": \"opensquirrel.passes.decomposer.mckay_decomposer.McKayDecomposer\",\n                    \"method\": \"decompose\",\n                    \"arguments\": {}\n                }\n            ]\n        }\n    },\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n}\n</code></pre>"},{"location":"request/meta.html#compiler-configuration","title":"Compiler configuration","text":"<p>The compiler configuration defines the pre-processing needed to convert the user-provided circuit into one that the backend can process. This comprises a list of steps that should be applied to the circuit using the Opensquirrel library. The config is represented as a dict and defines for each stage, a list of passes (ie preprocessing actions) that should be performed in the stage. Each pass includes settings such as the pass name, corresponding method invoked by opensquirrel and additional keyword arguments.</p> <p>If no <code>default_compiler_config</code> is provided, there will be no pre-processing steps applied to the circuit. The backend will receive the cQASM string the same way it was provided by the user.</p>"},{"location":"request/meta.html#get-dynamic","title":"Get dynamic","text":"<p>Dynamic information is generated by 2300. This information can for example constitute calibration data like T1 and T2*. This dynamic metadata fetched on a status change from <code>CALIBRATING</code>/<code>OFFLINE</code> to <code>IDLE</code> or on startup of 2200.</p> <p>Info</p> <p>The schemas for validation can be found in:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareDynamicDataRequest.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareDynamicDataResponse.schema.json</code></li> <li><code>/schemas/&lt;version&gt;/QuantumHardwareFailureResponse.schema.json</code></li> </ul> <p>or the alternative failure response for version 2 and older:</p> <ul> <li><code>/schemas/&lt;version&gt;/QuantumHardwareDataFailureResponse.schema.json</code></li> </ul>"},{"location":"request/meta.html#get-dynamic-request-payload","title":"Get dynamic request payload","text":"<p>This message does not require any additional information in the payload section.</p>"},{"location":"request/meta.html#get-dynamic-request-example","title":"Get dynamic request example","text":"get_dynamic_request.json<pre><code>{\n    \"command\": \"get_dynamic\",\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n}\n</code></pre>"},{"location":"request/meta.html#get-dynamic-reply-payload","title":"Get dynamic reply payload","text":"<p>The payload for this message contains an overview of one or more (or zero) metrics that can be used in a monitoring stack. In the table below, the format of a single metric is described. Keys between angular brackets (<code>&lt;</code>) are dynamic.</p> Key Type Value <code>&lt;metric_name&gt;</code> object Description of a single metric. The key is used as the metric name in Prometheus/Grafana. <code>__labels__</code> array The strings in this array are used as individual keys for labels in Prometheus/Grafana. <code>&lt;label_value&gt;</code> any The value can either be an object for nested values (see example 2), or an <code>int</code> or <code>float</code> for a leaf. The value of the (recursive) key is mapped by index to the labels in <code>__labels__</code> (e.g. <code>key1=q1</code> and <code>key2=x1</code>). The tree is traversed until a leaf is found. This value is interpreted as the value for the metric. If there is no value for the specific instance <code>null</code> can be reported, or the branch can be ommitted. <p>The reason that these labels are this important has to do with the aggregation and filtering of metrics. By specifying one metric which is measured for different data point, the dashboard can easily reference this metric. However, if necessary panels in the dashboard or alerts can also reference values for individual data points.</p>"},{"location":"request/meta.html#get-dynamic-reply-example-1-no-labels","title":"Get dynamic reply example 1: No labels","text":"get_dynamic_reply.json<pre><code>{\n    \"status\": \"success\",\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n    \"payload\": {\n        \"fridge_temperature_in_mk\": 8.4\n    },\n}\n</code></pre> <p>This will be represented in Prometheus/Grafana as:</p> <pre><code>qi_fridge_temperature_in_mk 8.4\n</code></pre>"},{"location":"request/meta.html#get-dynamic-reply-example-2-one-label","title":"Get dynamic reply example 2: One label","text":"get_dynamic_reply.json<pre><code>{\n    \"status\": \"success\",\n    \"payload\": {\n        \"t1\": {\n            \"__labels__\": [\"qubit\"],\n            \"q0\": 0.995,\n            \"q1\": 0.988\n        }\n    },\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n}\n</code></pre> <p>This will be represented in Prometheus/Grafana as:</p> <pre><code>qi_t1{qubit=q0} 0.995\nqi_t1{qubit=q1} 0.988\n</code></pre>"},{"location":"request/meta.html#get-dynamic-reply-example-2-multiple-labels","title":"Get dynamic reply example 2: Multiple labels","text":"get_dynamic_reply.json<pre><code>{\n    \"status\": \"success\",\n    \"payload\": {\n        \"cnot_fidelity\": {\n            \"__labels__\": [\"qubit1\", \"qubit2\"],\n            \"q1\": {\n                \"q0\": 0.995\n            }\n        }\n    },\n    \"session_id\": \"eb4fdc2c-755b-47d8-af76-bbca2dce554d\",\n}\n</code></pre> <p>This will be represented in Prometheus/Grafana as:</p> <pre><code>qi_cnot_fidelity{qubit1=q1, qubit2=q0} 0.995\n</code></pre>"}]}